# Group Finder - API Reference

## Overview

This document provides detailed API documentation for the Group Finder feature components. All classes and methods are designed to be used within the Spotify Favorites Analysis dashboard ecosystem.

## Core Classes

### Group (Data Class)

**File**: `src/models/group_formation.py:18-30`

A dataclass representing a music-based group with all its characteristics and metadata.

```python
@dataclass
class Group:
    id: int
    members: List[str]
    compatibility_score: float
    shared_genres: List[str]
    shared_artists: List[str]
    roast_name: str
    group_theme: str
    dominant_characteristics: Dict[str, float]
    member_data: List[Dict] = None
```

#### Attributes

| Attribute | Type | Description |
|-----------|------|-------------|
| `id` | `int` | Unique identifier for the group (0-based index) |
| `members` | `List[str]` | List of member names in the group |
| `compatibility_score` | `float` | Group compatibility percentage (0-100) |
| `shared_genres` | `List[str]` | Musical genres common to group members |
| `shared_artists` | `List[str]` | Artists shared by multiple group members |
| `roast_name` | `str` | Humorous group name generated by GroupNamer |
| `group_theme` | `str` | Explanation/description of the roast name |
| `dominant_characteristics` | `Dict[str, float]` | Average audio features and demographics |
| `member_data` | `List[Dict]` | Complete member information (optional) |

#### Example

```python
group = Group(
    id=0,
    members=['Alice', 'Bob', 'Charlie'],
    compatibility_score=87.3,
    shared_genres=['pop', 'country'],
    shared_artists=['taylor swift'],
    roast_name='Swifties (The Originals)',
    group_theme='Real fans since Fearless era',
    dominant_characteristics={
        'avg_energy': 0.72,
        'avg_age': 24.5,
        'avg_valence': 0.68,
        'avg_danceability': 0.65
    },
    member_data=[
        {'name': 'Alice', 'favorite_song': 'Love Story', 'artist': 'Taylor Swift', 'major': 'Psychology'},
        # ... more member data
    ]
)
```

### GroupFormationEngine

**File**: `src/models/group_formation.py:32-492`

Core engine for creating and managing music-based groups using constrained clustering algorithms.

#### Constructor

```python
def __init__(self, min_group_size: int = 3, max_group_size: int = 4, overflow_max: int = 6)
```

**Parameters:**
- `min_group_size` (int): Minimum people per group (default: 3)
- `max_group_size` (int): Target group size (default: 4)
- `overflow_max` (int): Maximum allowed group size for overflow handling (default: 6)

#### Public Methods

##### `create_groups(df: pd.DataFrame) -> List[Group]`

Creates optimized groups based on music similarity.

**Parameters:**
- `df` (pd.DataFrame): DataFrame with user data including music preferences

**Required DataFrame Columns:**
- `name` (str): Participant name
- `artist` (str): Favorite artist
- `favorite_song` (str): Favorite song
- `major` (str): Academic major

**Optional DataFrame Columns:**
- `genres` (str|List[str]): Musical genres (comma-separated or list)
- `age` (int): Participant age
- `audio_energy` (float): Spotify audio feature (0-1)
- `audio_valence` (float): Spotify audio feature (0-1)
- `audio_danceability` (float): Spotify audio feature (0-1)

**Returns:**
- `List[Group]`: List of optimized group objects

**Raises:**
- `ValueError`: If DataFrame is empty or missing required columns
- `RuntimeError`: If clustering algorithm fails

**Example:**
```python
engine = GroupFormationEngine(min_group_size=3, max_group_size=4)
groups = engine.create_groups(participant_df)

print(f"Created {len(groups)} groups")
for group in groups:
    print(f"Group {group.id}: {len(group.members)} members, {group.compatibility_score:.1f}% compatibility")
```

##### `get_group_by_member(member_name: str) -> Optional[Group]`

Finds which group a specific member belongs to.

**Parameters:**
- `member_name` (str): Name of the member to find

**Returns:**
- `Optional[Group]`: Group object if member is found, None otherwise

**Example:**
```python
group = engine.get_group_by_member('Alice')
if group:
    print(f"Alice is in {group.roast_name}")
else:
    print("Alice not found in any group")
```

##### `request_group_change(member_name: str, target_group_id: int) -> bool`

Processes a request to move a member to a different group.

**Parameters:**
- `member_name` (str): Name of member requesting change
- `target_group_id` (int): ID of target group to join

**Returns:**
- `bool`: True if request was successful, False if constraints violated

**Constraints Checked:**
- Current group must remain above minimum size
- Target group must be below maximum size
- Member must exist and be in a current group

**Example:**
```python
success = engine.request_group_change('Alice', target_group_id=2)
if success:
    print("Alice successfully moved to new group")
else:
    print("Request denied due to group size constraints")
```

#### Private Methods

##### `_calculate_similarity_matrix(df: pd.DataFrame) -> np.ndarray`

Calculates pairwise similarity matrix between all participants.

**Algorithm:**
- Genre similarity: Jaccard index (70% weight)
- Artist similarity: Exact/partial match (30% weight)
- Combined score: `0.7 * genre_sim + 0.3 * artist_sim`

**Returns:**
- `np.ndarray`: Symmetric nÃ—n similarity matrix where n = number of participants

##### `_constrained_clustering(similarity_matrix: np.ndarray, n_groups: int, n_people: int) -> List[int]`

Performs constrained K-means clustering to create balanced groups.

**Algorithm:**
- Converts similarity matrix to distance matrix
- Applies K-means with automatic cluster count determination
- Uses similarity matrix as feature space for clustering

**Returns:**
- `List[int]`: Cluster assignment for each participant

##### `_handle_overflow(group_assignments: List[int], df: pd.DataFrame) -> List[int]`

Redistributes members from groups that are too small.

**Logic:**
- Identifies groups below minimum size
- Finds best merge targets based on compatibility
- Respects maximum group size constraints

### GroupNamer

**File**: `src/utils/group_namer.py:14-361`

Generates humorous group names and themes based on music characteristics.

#### Constructor

```python
def __init__(self)
```

Initializes the naming system with predefined roast dictionaries for artists, genres, energy patterns, and age demographics.

#### Public Methods

##### `generate_group_names(groups: List[Group]) -> List[Group]`

Generates roast names and themes for all groups.

**Parameters:**
- `groups` (List[Group]): List of groups to name (roast_name and group_theme will be empty)

**Returns:**
- `List[Group]`: Same groups with roast_name and group_theme populated

**Naming Priority:**
1. Shared artists (highest priority)
2. Shared genres
3. Energy patterns (high/low energy)
4. Age demographics (young/old)
5. Mixed bag roasts (fallback)

**Example:**
```python
namer = GroupNamer()
named_groups = namer.generate_group_names(unnamed_groups)

for group in named_groups:
    print(f"{group.roast_name}: {group.group_theme}")
```

##### `add_custom_roast(artist: str, roasts: List[Tuple[str, str]])`

Adds custom roasts for specific artists.

**Parameters:**
- `artist` (str): Artist name (case-insensitive)
- `roasts` (List[Tuple[str, str]]): List of (name, theme) tuples

**Example:**
```python
namer.add_custom_roast('local_band', [
    ("Local Legends", "Supporting hometown heroes"),
    ("Indie Discoverers", "Found them before they were cool")
])
```

##### `add_genre_roast(genre: str, roasts: List[Tuple[str, str]])`

Adds custom roasts for specific genres.

**Parameters:**
- `genre` (str): Genre name (case-insensitive)
- `roasts` (List[Tuple[str, str]]): List of (name, theme) tuples

**Example:**
```python
namer.add_genre_roast('jazz', [
    ("Jazz Aficionados", "Sophisticated tastes for sophisticated people"),
    ("Smooth Operators", "Background music for coffee shops")
])
```

#### Private Methods

##### `_generate_single_group_name(group: Group) -> Tuple[str, str]`

Generates name and theme for a single group following priority hierarchy.

##### `_name_by_artist(group: Group) -> Tuple[str, str]`

Creates artist-based roasts with smart selection logic.

**Special Cases:**
- Taylor Swift: Differentiates by age (originals vs. new fans)
- Other artists: Selects based on group energy level

##### `_select_artist_roast(roasts: List[Tuple[str, str]], group: Group) -> Tuple[str, str]`

Intelligently selects most appropriate roast based on group characteristics.

## Integration APIs

### Streamlit Session State

The Group Finder integrates with Streamlit through session state management:

```python
# Required session state variables
st.session_state.current_groups: List[Group]         # Active groups
st.session_state.groups_finalized: bool             # Finalization status
st.session_state.group_change_requests: List[Dict]  # Pending requests
```

#### Session State Schema

```python
# Group change request structure
request = {
    'member': str,              # Name of requesting member
    'target_group': int,        # Target group ID
    'target_group_name': str    # Target group roast name
}
```

### Component Initialization

```python
# Initialize in Streamlit app
@st.cache_resource
def init_components():
    group_engine = GroupFormationEngine()
    group_namer = GroupNamer()
    return group_engine, group_namer

group_engine, group_namer = init_components()
```

## Data Models

### Input Data Format

```python
# Required DataFrame format
participant_data = pd.DataFrame({
    'name': ['Alice', 'Bob', 'Charlie'],
    'favorite_song': ['Love Story', 'Bohemian Rhapsody', 'Sicko Mode'],
    'artist': ['Taylor Swift', 'Queen', 'Travis Scott'],
    'major': ['Psychology', 'Physics', 'Computer Science']
})

# Optional enriched format with Spotify features
enriched_data = pd.DataFrame({
    'name': ['Alice', 'Bob', 'Charlie'],
    'favorite_song': ['Love Story', 'Bohemian Rhapsody', 'Sicko Mode'],
    'artist': ['Taylor Swift', 'Queen', 'Travis Scott'],
    'major': ['Psychology', 'Physics', 'Computer Science'],
    'genres': ['pop,country', 'rock,classic rock', 'hip hop,rap'],
    'age': [22, 21, 20],
    'audio_energy': [0.72, 0.89, 0.85],
    'audio_valence': [0.68, 0.45, 0.32],
    'audio_danceability': [0.65, 0.72, 0.90]
})
```

### Similarity Calculation

```python
# Genre similarity (Jaccard index)
def jaccard_similarity(set1: set, set2: set) -> float:
    intersection = len(set1 & set2)
    union = len(set1 | set2)
    return intersection / union if union > 0 else 0.0

# Artist similarity
def artist_similarity(artist1: str, artist2: str) -> float:
    if artist1.lower() == artist2.lower():
        return 1.0  # Exact match
    elif set(artist1.lower().split()) & set(artist2.lower().split()):
        return 0.5  # Partial word match
    else:
        return 0.0  # No match
```

## Error Handling

### Exception Types

```python
# Common exceptions that may be raised
ValueError          # Invalid input data or parameters
RuntimeError        # Algorithm failures or convergence issues
KeyError           # Missing required columns or data
IndexError         # Invalid group or member indices
TypeError          # Incorrect data types
```

### Error Recovery

```python
# Graceful error handling pattern
try:
    groups = group_engine.create_groups(df)
    named_groups = group_namer.generate_group_names(groups)
except ValueError as e:
    logger.error(f"Data validation error: {e}")
    # Fallback to simple round-robin grouping
    groups = create_simple_groups(df)
except RuntimeError as e:
    logger.error(f"Algorithm error: {e}")
    # Retry with different parameters
    engine = GroupFormationEngine(min_group_size=2, max_group_size=5)
    groups = engine.create_groups(df)
```

## Performance Characteristics

### Computational Complexity

| Operation | Time Complexity | Space Complexity |
|-----------|----------------|------------------|
| Similarity Matrix | O(nÂ²) | O(nÂ²) |
| K-means Clustering | O(nÃ—kÃ—i) | O(nÃ—k) |
| Name Generation | O(g) | O(1) |
| Group Validation | O(gÃ—m) | O(1) |

Where:
- n = number of participants
- k = number of clusters/groups
- i = clustering iterations
- g = number of groups
- m = average members per group

### Memory Usage

```python
# Approximate memory requirements
participants = 50
similarity_matrix_mb = (participants ** 2 * 8) / (1024 ** 2)  # ~0.02 MB
total_memory_mb = similarity_matrix_mb * 2  # ~0.04 MB for 50 people

# Memory scales quadratically with participant count
# 100 people: ~0.15 MB
# 200 people: ~0.6 MB
# 500 people: ~3.8 MB
```

## Testing APIs

### Mock Data Generation

```python
from src.api.google_sheets import MockGoogleSheetsClient

# Generate test data
mock_client = MockGoogleSheetsClient(sample_size=20)
test_df = mock_client.fetch_responses()

# Test group formation
engine = GroupFormationEngine()
groups = engine.create_groups(test_df)
named_groups = GroupNamer().generate_group_names(groups)

# Validate results
assert len(groups) > 0
assert all(3 <= len(group.members) <= 6 for group in groups)
assert all(group.roast_name for group in named_groups)
```

### Unit Test Helpers

```python
def create_test_group(members: List[str], shared_artists: List[str] = None) -> Group:
    """Helper function to create test groups."""
    return Group(
        id=0,
        members=members,
        compatibility_score=85.0,
        shared_genres=['pop'],
        shared_artists=shared_artists or [],
        roast_name='',
        group_theme='',
        dominant_characteristics={'avg_energy': 0.5}
    )

def assert_valid_groups(groups: List[Group], min_size: int = 3, max_size: int = 6):
    """Validates group constraints."""
    assert all(min_size <= len(group.members) <= max_size for group in groups)
    assert all(group.compatibility_score >= 0 for group in groups)
    assert all(group.roast_name and group.group_theme for group in groups)
```

---

*For implementation examples, see [Technical Guide](technical-guide.md)*
*For setup instructions, see [Setup Guide](setup-guide.md)*